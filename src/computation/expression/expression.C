// #define DEBUG_OPTIMIZE

#include <set>
#include <iterator>
#include <map>
#include <cctype>

#include "expression.H"
#include "computation/module.H"
#include "util.H"
#include "computation/operation.H"
#include "computation/operations.H"
#include "computation/graph_register.H"
#include "computation/expression/substitute.H"

using std::vector;
using std::string;
using std::set;
using std::multiset;

using boost::dynamic_pointer_cast;

expression_ref indexed_let_expression(const vector<expression_ref>& bodies, const expression_ref& T)
{
    expression* E = new expression( Let() );

    E->sub.push_back(T);

    for(const auto& body: bodies)
	E->sub.push_back(body);

    return E;
}

expression_ref let_expression(const vector<expression_ref>& vars, const vector<expression_ref>& bodies, const expression_ref& T)
{
    if (vars.size() == 0) return T;

    // We COULD merge with T if it is already a let expression, but
    // (a) We'd have to check that no variables overlap, and
    // (b) Sometimes sequential let's execute faster.
    // (c) Let's will probably be merged anyway during let-float.

    expression* E = new expression( let_obj() );
    E->sub.push_back(T);

    for(int i=0;i<vars.size();i++)
    {
	E->sub.push_back(vars[i]);
	E->sub.push_back(bodies[i]);
    }

    return E;
}

expression_ref let_expression(const expression_ref& var, const expression_ref& body, const expression_ref& T)
{
    return let_expression(vector<expression_ref>{var}, vector<expression_ref>{body}, T);
}

//let [(x[i], bodies[i])] T
bool parse_let_expression(const expression_ref& E, vector<expression_ref>& vars, vector<expression_ref>& bodies, expression_ref& T)
{
    vars.clear();
    bodies.clear();

    if (E.head().type() != let_type) return false;

    // There should be an odd number of arguments.
    assert(E.size()%2 == 1);

    T = E.sub()[0];
    const int L = (E.size()-1)/2;
    for(int i=0;i<L;i++)
    {
	vars.push_back(E.sub()[1+2*i]);
	bodies.push_back(E.sub()[2+2*i]);
    }

    return true;
}

//let T bodies[i]
bool parse_indexed_let_expression(const expression_ref& E, vector<expression_ref>& bodies, expression_ref& T)
{
    bodies.clear();

    if (E.head().type() != let2_type) return false;

    T = E.sub()[0];
    const int L = E.size()-1;
    bodies.resize(L);
    for(int i=0;i<L;i++)
	bodies[i] = E.sub()[i+1];

    return true;
}

/// R = case T of {patterns[i] -> bodies[i]}
bool parse_case_expression(const expression_ref& E, expression_ref& T, vector<expression_ref>& patterns, vector<expression_ref>& bodies)
{
    patterns.clear();
    bodies.clear();

    if (E.head().type() != case_type) return false;

    T = E.sub()[0];
    const int L = (E.size()-1)/2;
    patterns.resize(L);
    bodies.resize(L);
    for(int i=0;i<L;i++)
    {
	patterns[i] = E.sub()[1 + 2*i];
	bodies[i] = E.sub()[2 + 2*i];
    }

    return true;
}


bool dummy::operator==(const dummy& d) const
{
    return index == d.index and name == d.name;
}

tribool dummy::compare(const Object& o) const 
{
    const dummy* D = dynamic_cast<const dummy*>(&o);
    if (not D) 
	return false;

    return (*this) == *D;
}

identifier::identifier(const std::string& s)
    :name(s)
{
    assert(not name.empty());
}

string Trim::print() const
{
    return "Trim";
}

tribool Trim::compare(const Object& o) const 
{
    const Trim* T = dynamic_cast<const Trim*>(&o);
    return T;
}

string dummy::print() const {
    if (is_wildcard())
	return "_";
    else if (name.size() and index == -1)
	return name;
    else
	return name+string("#")+convertToString(index);
}

bool dummy::operator<(const dummy& D) const 
{
    if (name.size() and not D.name.size())
	return true;

    if (not name.size() and D.name.size())
	return false;

    if (name.size())
	return name < D.name;
    else
	return index < D.index;
}

tribool let_obj::compare(const Object& o) const 
{
    const let_obj* T = dynamic_cast<const let_obj*>(&o);
    return T;
}

string let_obj::print() const 
{
    return "let";
}

tribool parameter::compare(const Object& o) const 
{
    const parameter* E = dynamic_cast<const parameter*>(&o);
    if (not E) 
	return false;

    return parameter_name == E->parameter_name;
}

parameter::parameter(const std::string& s)
    :parameter_name(s)
{
}

string lambda::print() const {
    return "lambda";
}

tribool lambda::compare(const Object& o) const 
{
    return dynamic_cast<const lambda*>(&o);
}

string lambda2::print() const {
    return "/\\";
}

tribool lambda2::compare(const Object& o) const 
{
    return dynamic_cast<const lambda2*>(&o);
}

expression_ref lambda_quantify(const expression_ref& dummy, const expression_ref& R)
{
    return new expression(lambda(),{dummy, R});
}

expression_ref lambda_quantify(int dummy_index, const expression_ref& R)
{
    return lambda_quantify(dummy(dummy_index), R);
}

expression_ref lambda_expression(const Operator& O)
{
    int n = O.n_args();
    assert(n != -1);
  
    expression_ref R;
    if (n == 0)
	R = expression_ref(O.clone());
    else
    {
	expression* E = new expression(O);
	for(int i=0;i<n;i++)
	    E->sub.push_back(expression_ref(dummy(i)));
	R = expression_ref(E);
    }
  
    for(int i=n-1;i>=0;i--) 
	R = lambda_quantify(i,R);
  
    return R;
}

vector<int> pop_vars(int n, vector<int> vars)
{
    assert(n >= 0);
    if (n == 0) return vars;

    for(int& var: vars)
	var -= n;
    while(vars.size() and vars[0] < 0)
	vars.erase(vars.begin());
    return vars;
}

vector<int> merge_vars(const vector<int>& v1, const vector<int>& v2)
{
    int i=0;
    int j=0;
    vector<int> v3;
    while(i<v1.size() or j<v2.size())
    {
	if (i >= v1.size())
	    v3.push_back(v2[j++]);
	else if (j >= v2.size())
	    v3.push_back(v1[i++]);
	else if (v1[i] < v2[j])
	    v3.push_back(v1[i++]);
	else if (v1[i] > v2[j])
	    v3.push_back(v2[j++]);
	else {
	    assert(v1[i] == v2[j]);
	    v3.push_back(v1[i]);
	    i++; j++;
	}
    }
    assert(v3.size() >= v1.size());
    assert(v3.size() >= v2.size());
    return v3;
}

vector<int> get_free_index_vars(const expression_ref& E)
{
    if (not E.size()) 
    {
	// Variable
	if (E.is_index_var())
	    return {E.as_index_var()};
	// Constant
	else
	    return vector<int>{};
    }

    vector<expression_ref> bodies;
    vector<expression_ref> patterns;
    expression_ref T;

    vector<int> vars;
  
    if (E.head().is_a<Trim>())
    {
	// Which vars are we not throwing away?
	// This should also be an assert.
	vars = E.sub()[0].as_<Vector<int>>();
    
#ifndef NDEBUG
	vector<int> vars2 = get_free_index_vars(E.sub()[1]);
	assert(vars.size() == vars2.size());
	for(int i=0;i<vars.size();i++)
	    assert(vars2[i] == i);
#endif
    }
    // Lambda expression - /\x.e
    else if (E.head().is_a<lambda2>())
	vars = pop_vars(1, get_free_index_vars(E.sub()[0]));

    // Let expression
    else if (parse_indexed_let_expression(E, bodies, T))
    {
	vars = get_free_index_vars(T);

	for(const auto& body: bodies)
	    vars = merge_vars(vars, get_free_index_vars(body));

	vars = pop_vars(bodies.size(), vars);
    }

    // case expression
    else if (parse_case_expression(E, T, patterns, bodies))
    {
	vars = get_free_index_vars(T);

	for(int i=0;i<bodies.size();i++)
	{
	    int n = 0;

	    // Handle c[i] x[i][1..n] -> body[i]
	    if (patterns[i].head().is_a<constructor>())
		n = patterns[i].head().as_<constructor>().n_args();

	    vars = merge_vars(vars, pop_vars(n, get_free_index_vars(bodies[i])) );
	}
    }
    else
    {
	for(int i=0;i<E.size();i++)
	    vars = merge_vars(vars, get_free_index_vars(E.sub()[i]) );
    }

    //  std::cerr<<"fv("<<R<<"): "<<join(vars,",")<<"\n";

    return vars;
}

expression_ref trim_normalize(const expression_ref& E)
{
    // Already normalized (though not trimmed)
    if (not E.size()) return E;

    vector<expression_ref> bodies;
    vector<expression_ref> patterns;
    expression_ref T;

    vector<int> vars;
  
    // Let expressions need to be normalized
    if (parse_indexed_let_expression(E, bodies, T))
    {
	T = trim(trim_normalize(T));

	for(auto& body: bodies)
	    body = trim(trim_normalize(body));

	return indexed_let_expression(bodies,T);
    }

    // case expression
    else if (parse_case_expression(E, T, patterns, bodies))
    {
	// T should already be a variable, so don't bother about it.
	assert(T.is_index_var());

	for(auto& body: bodies)
	    body = trim(trim_normalize(body));

	return make_case_expression(T, patterns, bodies);
    }
    else
    {
	expression* V = E.as_expression().clone();
	for(int i=0;i<E.size();i++)
	    V->sub[i] = trim_normalize(V->sub[i]);

	return V;
    }
}

expression_ref make_trim(const expression_ref& E, const vector<int>& indices)
{
#ifndef NDEBUG
    vector<int> vars = get_free_index_vars(E);
    for(int i=0;i<vars.size();i++)
	assert(vars[i] == i);
    assert(indices.size() == vars.size());
#endif

    expression* V = new expression(Trim());
    V->sub.push_back(Vector<int>(indices));
    V->sub.push_back(E);

    return V;
}

// This compresses free variables according to the supplied mapping.
expression_ref remap_free_indices(const expression_ref& E, const vector<int>& mapping, int depth)
{
    if (not E.size())
    {
	// Variable
	if (E.is_index_var())
	{
	    int index = E.as_index_var();
	    int delta = index - depth;
	    if (delta >= 0)
	    {
		assert(delta < mapping.size());
		assert(mapping[delta] != -1);

		return index_var(depth + mapping[delta]);
	    }
	    else
		// Var that is to new to be remapped.
		return E;
	}
	// Constant
	else
	    return E;
    }

    vector<expression_ref> bodies;
    vector<expression_ref> patterns;
    expression_ref T;

    vector<int> vars;
  
    if (E.head().is_a<Trim>())
    {
	// Which vars are we not throwing away?
	// This should also be an assert.
	vars = E.sub()[0].as_<Vector<int>>();

	// remap free vars
	for(auto& var:vars)
	{
	    int delta = var - depth;
	    if (delta >= 0)
	    {
		assert(delta < mapping.size());
		assert(mapping[delta] != -1);

		var = depth + mapping[delta];
	    }
	}
    
#ifndef NDEBUG
	vector<int> vars2 = get_free_index_vars(E.sub()[1]);
	assert(vars.size() == vars2.size());
	for(int i=0;i<vars.size();i++)
	    assert(vars2[i] == i);
#endif

	return make_trim(E.sub()[1], vars);

    }
    // Lambda expression - /\x.e
    else if (E.head().is_a<lambda2>())
    {
	expression* V = new expression(lambda2());
	V->sub.push_back(remap_free_indices(E.sub()[0], mapping, depth+1));
	return V;
    }

    // Let expression
    else if (parse_indexed_let_expression(E, bodies, T))
    {
	int n = bodies.size();
	T = remap_free_indices(T, mapping, depth + n);

	for(auto& body: bodies)
	    body = remap_free_indices(body, mapping, depth + n);

	return indexed_let_expression(bodies, T);
    }
  
    // case expression
    else if (parse_case_expression(E, T, patterns, bodies))
    {
	T = remap_free_indices(T, mapping, depth);

	for(int i=0;i<bodies.size();i++)
	{
	    int n = 0;

	    // Handle c[i] x[i][1..n] -> body[i]
	    if (patterns[i].head().is_a<constructor>())
		n = patterns[i].head().as_<constructor>().n_args();

	    bodies[i] = remap_free_indices(bodies[i], mapping, depth + n);
	}

	return make_case_expression(T, patterns, bodies);
    }
    else
    {
	expression* V = E.as_expression().clone();
	for(int i=0;i<E.size();i++)
	    V->sub[i] = remap_free_indices(V->sub[i], mapping, depth);
	return V;
    }
}

expression_ref trim(const expression_ref& E)
{
    // Well, it would seem that the relevant matter is that we are at depth n.
    vector<int> indices = get_free_index_vars(E);

    vector<int> mapping;

    if (indices.size())
    {
	mapping = vector<int>(indices.back()+1, -1);
	for(int i=0;i<indices.size();i++)
	    mapping[indices[i]] = i;
    }

    return make_trim( remap_free_indices(E, mapping, 0), indices);
}

expression_ref untrim(const expression_ref& E)
{
    if (E.head().is_a<Trim>())
	return remap_free_indices(E.sub()[1], E.sub()[0].as_<Vector<int>>(), 0);
    else
	return E;
}

// This only removes trimmers from the places that trim_normalize puts them.
// (Since remap_free_indices( ) doesn't enter trimmers, this should be relatively efficient,
//  just like trim_normalize( ))
expression_ref trim_unnormalize(const expression_ref& E)
{
    // Already normalized (though not trimmed)
    if (not E.size()) return E;

    vector<expression_ref> bodies;
    vector<expression_ref> patterns;
    expression_ref T;

    vector<int> vars;
  
    // Let expressions need to be normalized
    if (parse_indexed_let_expression(E, bodies, T))
    {
	T = trim_unnormalize(untrim(T));

	for(auto& body: bodies)
	    body = trim_unnormalize(untrim(body));

	return indexed_let_expression(bodies,T);
    }

    // case expression
    else if (parse_case_expression(E, T, patterns, bodies))
    {
	// T should already be a variable, so don't bother about it.
	assert(T.is_index_var());

	for(auto& body: bodies)
	    body = trim_unnormalize(untrim(body));

	return make_case_expression(T, patterns, bodies);
    }
    else
    {
	expression* V = E.as_expression().clone();
	for(int i=0;i<V->size();i++)
	    V->sub[i] = trim_unnormalize(untrim(V->sub[i]));

	return V;
    }
}

/// 1. Hey, could we solve the problem of needing to rename dummies by doing capture-avoiding substitution?
/// I think we could!
///
/// Suppose we have Lf.Lx.fx, and we apply it to Lx.x (the identity function), then we get
///    (Lf.Lx.fx)(Lx.x) = (Lx.fx)[f := Lx.x] = Lx.(Lx.x)x.
/// Then, if we apply this to y, we get
///    (Lx.(Lx.x)x)y = (Lx.x)x[x := y] = (Lx.x)y 
/// And
///    (Lx.x)y = y;
///
/// 2. However, is sometimes still necessary to rename dummies.  This is true if E2 contains unbound dummies
///    that are bound in E1.
///
///    For example, apply Lx.y to x, then we would get Lx.x, which is not allowed.
///    Instead, we must "alpha-convert" Lx.y to Lz.y, and then apply Lz.y to x, leading to Lz.x .

/// Literally E2 for D in E1. (e.g. don't rename variables in E2).  Throw an exception if D is a lambda-bound dummy variable.

std::set<dummy> get_free_indices(const expression_ref& E);

/// Return the min of v
template<typename T>
T max(const std::set<T>& v)
{
    T t = *v.begin();
    for(const auto& i: v)
	t = std::max(t,i);

    return t;
}

int max_index(const std::set<dummy>& s)
{
    if (s.empty()) return -1;
    return max(s).index;
}

/// Return the min of v
template<typename T>
T min(const std::set<T>& v)
{
    T t = *v.begin();
    for(const auto& i: v)
	t = std::min(t,*i);

    return t;
}

// Return the list of dummy variable indices that are bound at the top level of the expression
std::set<dummy> get_bound_indices(const expression_ref& E)
{
    std::set<dummy> bound;

    if (not E.size()) return bound;

    // Make sure we don't try to substitute for lambda-quantified dummies
    if (E.head().type() == lambda_type)
    {
	if (E.sub()[0].is_a<dummy>())
	    bound.insert(E.sub()[0].as_<dummy>());
    }
    else 
    {
	if (E.head().type() == let_type)
	{
	    const int L = (E.size()-1)/2;
	    for(int i=0;i<L;i++)
	    {
		if (E.sub()[1+2*i].is_a<dummy>())
		    bound.insert(E.sub()[1+2*i].as_<dummy>());
	    }
	}
	assert(not E.head().is_a<Case>());
    }

    return bound;
}

void get_free_indices2(const expression_ref& E, multiset<dummy>& bound, set<dummy>& free)
{
    // fv x = { x }
    if (is_dummy(E))
    {
	dummy d = E.as_<dummy>();
	if (not is_wildcard(E) and (bound.find(d) == bound.end()))
	    free.insert(d);
	return;
    }

    // fv c = { }
    if (not E.size()) return;

    // for case expressions get_bound_indices doesn't work correctly.
    if (E.head().type() == case_type)
    {
	get_free_indices2(E.sub()[0], bound, free);

	const int L = (E.size()-1)/2;

	for(int i=0;i<L;i++)
	{
	    std::set<dummy> bound_ = get_free_indices(E.sub()[1+2*i]);
	    for(const auto& d: bound_)
		bound.insert(d);
	    get_free_indices2(E.sub()[2+2*i], bound, free);
	    for(const auto& d: bound_)
	    {
		auto it = bound.find(d);
		bound.erase(it);
	    }
	}

	return;
    }

    std::set<dummy> bound_ = get_bound_indices(E);
    for(const auto& d: bound_)
	bound.insert(d);
    for(int i=0;i<E.size();i++)
	get_free_indices2(E.sub()[i], bound, free);
    for(const auto& d: bound_)
    {
	auto it = bound.find(d);
	bound.erase(it);
    }
}

std::set<dummy> get_free_indices(const expression_ref& E)
{
    multiset<dummy> bound;
    set<dummy> free;
    get_free_indices2(E, bound, free);
    return free;
}

int get_safe_binder_index(const expression_ref& E)
{
    std::set<dummy> free = get_free_indices(E);
    if (free.empty()) 
	return 0;
    else
	return max_index(free)+1;
}

int n_free_occurrences(const expression_ref& E1, const expression_ref& D)
{
    assert(not is_wildcard(D));

    // If this is the relevant dummy, then substitute
    if (E1.size() == 0)
    {
	if (E1 == D)
	    return 1;
	// If this is any other constant, then it doesn't contain the dummy
	else
	    return 0;
    }

    // Handle case expressions differently
    {
	expression_ref T;
	vector<expression_ref> patterns;
	vector<expression_ref> bodies;
	if (parse_case_expression(E1,T,patterns,bodies))
	{
	    int count = n_free_occurrences(T, D);

	    const int L = (E1.size()-1)/2;

	    for(int i=0;i<L;i++)
	    {
		// don't substitute into subtree where this variable is bound
		std::set<dummy> bound = get_free_indices(patterns[i]);

		bool D_is_bound = false;
		for(const auto& b: bound)
		    if (D == b) D_is_bound=true;

		if (not D_is_bound)
		    count += n_free_occurrences(bodies[i], D);
	    }

	    return count;
	}
    }

    // What indices are bound at the top level?
    std::set<dummy> bound = get_bound_indices(E1);

    // Don't substitute into local variables
    for(const auto& b: bound)
	if (D == b) return 0;
    
    // Since this is an expression, count occurrences in sub-expressions
    int count = 0;
    for(int i=0;i<E1.size();i++)
	count += n_free_occurrences(E1.sub()[i], D);

    return count;
}

void find_named_parameters(const expression_ref& E, std::set<string>& names)
{
    assert(E);
    // If this is a parameter, then makes sure we've got its name.
    if (E.is_a<parameter>())
    {
	auto& n = E.as_<parameter>();
	assert(not E.size());
	if (names.find(n.parameter_name) == names.end())
	    names.insert(n.parameter_name);
    }

    // Check the sub-objects of this expression.
    for(int i=0;i<E.size();i++)
	find_named_parameters(E.sub()[i], names);
}

set<string> find_named_parameters(const expression_ref& e)
{
    set<string> names;
    find_named_parameters(e, names);
    return names;
}

set<string> find_named_parameters(const vector<expression_ref>& notes)
{
    set<string> names;
    for(int i=0;i<notes.size();i++)
	find_named_parameters(notes[i], names);
    return names;
}

expression_ref add_prefix(const string& prefix, const expression_ref& E)
{
    std::set<string> names = find_named_parameters(E);

    expression_ref E2 = E;
    for(const auto& name: names)
	E2 = substitute(E2, parameter(name), parameter(prefix+"."+name));

    return E2;
}

expression_ref Cons = lambda_expression( right_assoc_constructor(":",2) );

expression_ref ListEnd = lambda_expression( constructor("[]",0) );

vector<expression_ref> get_ref_vector_from_list(const expression_ref& E)
{
    vector<expression_ref> V;

    expression_ref E2 = E;
    while(has_constructor(E2,":"))
    {
	assert(E2.size() == 2);
	V.push_back(E2.sub()[0]);
	E2 = E2.sub()[1];
    }
    assert(has_constructor(E2,"[]"));

    return V;
}

template<> expression_ref get_tuple<>(const vector<expression_ref>& S)
{
    if (S.size() == 0) return constructor("()",0);

    if (S.size() == 1) return S[0];

    constructor H = tuple_head(S.size());

    if (not S.size()) return H;

    return new expression(H,S);
}

template<> expression_ref get_list<>(const vector<expression_ref>& v)
{
    expression_ref E = ListEnd;

    for(int i=v.size()-1;i>=0;i--)
	E = v[i]&E;

    return E;
}

/* Legal terms are:

   T,U,V -> x
   -> Lx.T
   -> U T
   -> c U[]
   -> let {x=U} in T
   -> case U of {c x[i] -> V[i]}
*/

/* The normalization rules are:

   1. (x)* -> x
   2. (Lx.T)* -> Lx.(T)*
   3. (U T)* -> let x = (T)* in (U)* x , x fresh
   4. (c U[i]) -> let x[i] = (U[i])* in c x[i], x fresh
   5. (let {x[i] = U[i]} in T)* -> let {x=(U[i])*} in (T)*
   6. (case U of {c[i] x[i][] -> T[i]})* -> case (U)* of {c[i] x[i][] -> (T[i])*}
*/

/*
  x -> dummy[index]
  Lx.T ->(lambda[index] T)
  (U T) -> (U T)
  (c U[i]) -> (c U[i])
  (let {x[i] = U[i]} in T) -> (let [(x[i],U[i])] T)
  (case T in {c[i] x[i] -> U[i]}) -> (case T [(c[i] x[i],U[i])]
*/

/*
 *  Perhaps switch to (lambda dummy E) instead of (lambda[index] E)
 */ 

bool is_irrefutable_pattern(const expression_ref& E)
{
    return E.is_a<dummy>();
}

/// Is this either (a) irrefutable, (b) a constant, or (c) a constructor whose arguments are irrefutable patterns?
bool is_simple_pattern(const expression_ref& E)
{
    // (a) Is this irrefutable?
    if (is_irrefutable_pattern(E)) return true;

    // (b) Is this a constant with no arguments? (This can't be an irrefutable pattern, since we've already bailed on dummy variables.)
    if (not E.size()) return true;

    assert(E.head().is_a<constructor>());

    // Arguments of multi-arg constructors must all be irrefutable patterns
    for(int j=0;j<E.size();j++)
	if (not is_irrefutable_pattern(E.sub()[j]))
	    return false;

    // (c) Is this a constructor who arguments are irrefutable patterns?
    return true;
}

// This function currently assumes that all the patterns are just variables.

expression_ref case_expression(const expression_ref& T, const vector<expression_ref>& patterns, const vector<expression_ref>& bodies);

/// Create the expression case T of {patterns[i] -> bodies[i]} --- AND all patterns are just C[i] v1 v2 ... vn
expression_ref simple_case_expression(const expression_ref& T, const vector<expression_ref>& patterns, const vector<expression_ref>& bodies)
{
    expression_ref E = make_case_expression(T, patterns, bodies);

    for(int i=patterns.size()-1;i>=0;i--)
    {
	if (not is_simple_pattern(patterns[i]))
	    throw myexception()<<"simple_case_expression( ): pattern '"<<patterns[i]<<"' is not free variable in expression '"<<E<<"'";
    }

    return E;
}

template <typename T>
vector<T> skip(int n, const vector<T>& v)
{
    if (v.size() <= n) return vector<T>();

    vector<T> v2(v.size() - n);
    for(int i=0;i<v2.size();i++)
	v2[i] = v[i+n];

    return v2;
}

expression_ref make_case_expression(const expression_ref& T, const vector<expression_ref>& patterns, const vector<expression_ref>& bodies)
{
    assert(patterns.size() == bodies.size());

    expression* E = new expression( Case() );
    E->sub.push_back(T);
  
    for(int i=0;i<patterns.size();i++)
    {
	E->sub.push_back( patterns[i] );
	E->sub.push_back( bodies[i] );
    }
    return E;
}

int find_object(const vector<expression_ref>& v, const expression_ref& E)
{
    for(int i=0;i<v.size();i++)
	if (E == v[i])
	    return i;
    return -1;
}

// FIXME: we perform 3 case operations in the case of zip x:xs [] because we create an 'otherwise' let-var that
//        performs a case on y:ys that has already been done.

/*
 * case (x[0],..,x[N-1]) of (p[0...M-1][0...N-1] -> b[0..M-1])
 *
 * 1. Categorize each rule according to the type of its top-level pattern.
 * 2. Substitute for the irrefutable rules to find the 'otherwise' branch.
 * 3. Find the bodies for what happens after we match the various constants.
 *
 * If the otherwise branch is used twice, then construct a let-expression for it.
 *
 */
expression_ref block_case(const vector<expression_ref>& x, const vector<vector<expression_ref>>& p, const vector<expression_ref>& b)
{
    const int N = x.size();
    const int M = p.size();

    assert(p.size() == b.size());

    // Each pattern must have N components.
    for(int j=0;j<M;j++)
	assert(p[j].size() == N);

    if (not x.size())
	return b[0];

    // 1. Categorize each rule according to the type of its top-level pattern
    vector<expression_ref> constants;
    vector< vector<int> > rules;
    vector<int> irrefutable_rules;
    for(int j=0;j<M;j++)
    {
	if (is_dummy(p[j][0]))
	{
	    irrefutable_rules.push_back(j);
	    continue;
	}

	expression_ref C = p[j][0].head();
	int which = find_object(constants, C);

	if (which == -1)
	{
	    which = constants.size();
	    constants.push_back(C);
	    rules.push_back(vector<int>{});
	}

	rules[which].push_back(j);
    }

    // 2. Substitute for the irrefutable rules to find the 'otherwise' branch
    // This is substitute(x[1],p[2..m][1], case x2...xN of p[2..M][i] -> b[2..M] )
    expression_ref otherwise;
    if (irrefutable_rules.empty())
	; // otherwise = NULL
    else
    {
	vector<expression_ref> x2 = x;
	x2.erase(x2.begin());

	vector<vector<expression_ref>> p2;
	vector<expression_ref> b2;
	for(int i=0;i<irrefutable_rules.size();i++)
	{
	    int r = irrefutable_rules[i];
	    p2.push_back(p[r]);
	    p2.back().erase(p2.back().begin());

	    b2.push_back(b[r]);

	    if (is_wildcard(p[r][0]))
		// This is a dummy.
		; //assert(d->name.size() == 0);
	    else
	    {
		// FIXME! What if x[0] isn't a var?
		// Then if *d occurs twice, then we should use a let expression, right?
		b2[i] = substitute(b2[i], p[r][0].as_<dummy>(), x[0]);
	    }
	}
      
	if (x2.empty())
	{
	    // If (b2.size() > 1) then we have duplicate irrefutable rules, but that's OK.
	    // This can even be generated in the process of simplifying block_case expressions.	
	    otherwise = b2[0];
	}
	else
	    otherwise = block_case(x2, p2, b2);
    }
      
    // If there are no conditions on x[0], then we are done.
    if (constants.empty())
    {
	assert(otherwise);
	return otherwise;
    }

    // Find the first safe var index
    std::set<dummy> free;

    for(int i=0;i<x.size();i++)
	add(free, get_free_indices(x[i]));

    for(int i=0;i<p.size();i++)
    {
	add(free, get_free_indices(b[i]));
  
	for(int j=0; j<p[i].size(); j++)
	    add(free, get_free_indices(p[i][j]));
    }
  
    int var_index = 0;
    if (not free.empty()) var_index = max_index(free)+1;

    // WHEN should we put the otherwise expression into a LET variable?
    expression_ref O;
    if (otherwise) O = dummy(var_index++);

    // 3. Find the modified bodies for the various constants
    vector<expression_ref> simple_patterns;
    vector<expression_ref> simple_bodies;
    bool all_simple_followed_by_irrefutable = true;

    for(int c=0;c<constants.size();c++)
    {
	// Find the arity of the constructor
	int arity = 0;
	if (constants[c].head().is_a<constructor>())
	    arity = constants[c].head().as_<constructor>().n_args();

	// Construct the simple pattern for constant C
	expression_ref H = constants[c];

	vector<expression_ref> S(arity);
	for(int j=0;j<arity;j++)
	    S[j] = dummy(var_index+j);

	int r0 = rules[c][0];

	simple_patterns.push_back({H,S});
	simple_bodies.push_back({});
    
	// Construct the objects for the sub-case expression: x2[i] = v1...v[arity], x[2]...x[N]
	vector<expression_ref> x2;
	for(int j=0;j<arity;j++)
	    x2.push_back(S[j]);
	x2.insert(x2.end(), x.begin()+1, x.end());

	// Are all refutable patterns on x[1] simple and followed by irrefutable patterns on x[2]...x[N]?
	bool future_patterns_all_irrefutable = true;

	// Construct the various modified bodies and patterns
	vector<expression_ref> b2;
	vector<vector<expression_ref> > p2;
	for(int i=0;i<rules[c].size();i++)
	{
	    int r = rules[c][i];

	    // Add the pattern
	    p2.push_back(vector<expression_ref>{});
	    assert(p[r][0].size() == arity);

	    // Add sub-patterns of p[r][1]
	    for(int k=0;k<arity;k++)
		p2.back().push_back(p[r][0].sub()[k]);

	    p2.back().insert(p2.back().end(), p[r].begin()+1, p[r].end());

	    // Add the body
	    b2.push_back(b[r]);

	    // Check if p2[i] are all irrefutable
	    for(int i=0;i<p2.back().size();i++)
		if (not is_irrefutable_pattern(p2.back()[i]))
		{
		    future_patterns_all_irrefutable = false;
		    all_simple_followed_by_irrefutable = false;
		}
	}

	// If x[1] matches a simple pattern in the only alternative, we may as well
	// not change the variable names for the match slots in this pattern.
	if (rules[c].size() == 1 and is_simple_pattern(p[r0][0]))
	{
	    simple_patterns.back() = p[r0][0];

	    // case x[1] of p[r0][1] -> case (x[2],..,x[N]) of (p[r0][2]....p[r0][N]) -> b[r0]
	    x2 = x;
	    x2.erase(x2.begin());

	    p2.back() = p[r0];
	    p2.back().erase( p2.back().begin() );
	}

	// If all future patterns are irrefutable, then we won't need to backtrack to the otherwise case.
	if (future_patterns_all_irrefutable)
	{
	    // There can be only one alternative.
	    assert(rules[c].size() == 1);

	    if (x2.size())
		simple_bodies.back() = block_case(x2, p2, b2);
	    else
		simple_bodies.back() = b[r0];
	}
	else
	{
	    if (otherwise)
	    {
		p2.push_back(vector<expression_ref>(x2.size(), dummy(-1)));
		// Since we could backtrack, use the dummy.  It will point to otherwise
		b2.push_back(O);
	    }
	    simple_bodies.back() = block_case(x2, p2, b2);
	}
    }

    if (otherwise)
    {
	simple_patterns.push_back(dummy(-1));
	// If we have any backtracking, then use the otherwise dummy, like the bodies.
	if (not all_simple_followed_by_irrefutable)
	    simple_bodies.push_back(O);
	else
	    simple_bodies.push_back(otherwise);
    }

    // Construct final case expression
    expression_ref CE = make_case_expression(x[0], simple_patterns, simple_bodies);

    if (otherwise and not all_simple_followed_by_irrefutable)
	CE = let_expression(O, otherwise, CE);

    return CE;
}

// Create the expression 'case T of {patterns[i] -> bodies[i]}'
// Create the expression 'case (T) of {(patterns[i]) -> bodies[i]}'
expression_ref case_expression(const expression_ref& T, const vector<expression_ref>& patterns, const vector<expression_ref>& bodies)
{
    vector<vector<expression_ref>> multi_patterns;
    for(const auto& p:patterns)
	multi_patterns.push_back({p});
    return block_case({T}, multi_patterns, bodies);
}

expression_ref case_expression(const expression_ref& T, const expression_ref& pattern, const expression_ref& body, const expression_ref& otherwise)
{
    vector<expression_ref> patterns = {pattern};
    vector<expression_ref> bodies = {body};
    if (otherwise and not pattern.is_a<dummy>())
    {
	patterns.push_back(dummy(-1));
	bodies.push_back(otherwise);
    }
    return case_expression(T,patterns, bodies);
}

expression_ref def_function(const vector< vector<expression_ref> >& patterns, const vector<expression_ref>& bodies)
{
    // Find the first safe var index
    std::set<dummy> free;

    for(int i=0;i<patterns.size();i++)
    {
	add(free, get_free_indices(bodies[i]));
  
	for(int j=0; j<patterns[i].size(); j++)
	    add(free, get_free_indices(patterns[i][j]));
    }
  
    int var_index = 0;
    if (not free.empty()) var_index = max_index(free)+1;

    // All versions of the function must have the same arity
    assert(patterns.size());
    for(int i=1;i<patterns.size();i++)
	assert(patterns[0].size() == patterns[i].size());

    // Construct the dummies
    vector<expression_ref> args;
    for(int i=0;i<patterns[0].size();i++)
	args.push_back(dummy(var_index+i));
    
    // Construct the case expression
    expression_ref E = block_case(args, patterns, bodies);

    // Turn it into a function
    for(int i=patterns[0].size()-1;i>=0;i--)
	E = lambda_quantify(var_index+i, E);

    return E;
}

/*
  expression_ref def_function(const vector<expression_ref>& patterns, const expression_ref& body)
  {
  return def_function(vector< vector<expression_ref> >(1,patterns), vector<expression_ref>(1,body));
  }


  expression_ref def_function(const vector<expression_ref>& pattern, const vector<expression_ref>& bodies)
  {
  vector< vector<expression_ref> > patterns;

  for(const auto& p: pattern)
  {
  patterns.push_back( vector<expression_ref>() );

  if (not p->size())
  patterns.back().push_back(p);
  else
  for(int i=0;i<p->size();i++)
  patterns.back().push_back(p.sub()[i]);
  }

  return def_function(patterns, bodies);
  }

  expression_ref def_function(const expression_ref& pattern, const expression_ref& body)
  {
  return def_function(vector<expression_ref>(1,pattern), vector<expression_ref>(1,body));
  }
*/

// Def: a redex is an expression that matches the LHS of a reduction rule.

// NF = the expression contains no redexes.

// HNF = an expression that is either:
//  * a variable
//  * a data value
//  * a built-in function applied to too few arguments
//  * a lambda abstraction whose body is not reducible.
// An expression in HNF may contain redexes in argument positions whereas a NF may not.
// - but how?

// WHNF = Weak head normal form. WHNF terms have no restriction on the body of lambdas, and so include:
//  * a variable
//  + a data value
//  + a built-in Operation (like "+") with too few arguments.
//  * a lambda expression
//  + a constructor
// The terms in + are extensions to the basic lambda calculus.
// Question: how about the expression (@ x y), which cannot be reduced?

// Basically, HNF requires that the body of a lambda is reduced as well, while WHNF does not have this requirement.
// Therefore, \x -> 1+1 is WHNF but not HNF.

bool is_WHNF(const expression_ref& E)
{
    int type = E.head().type();
    if (E.size())
    {
	assert(not E.head().is_a<lambda>());

	if (type == lambda2_type or type == constructor_type) 
	    return true;
	else
	    return false;
    }
    else
    {
	if (type == parameter_type) 
	    return false;
	else if (type == modifiable_type) 
	    return false;
	else
	    return true;
    }
}

bool is_dummy(const expression_ref& E)
{
    return (E.head().type() == dummy_type);
}

bool is_parameter(const expression_ref& E)
{
    return E.is_a<parameter>();
}

bool is_modifiable(const expression_ref& E)
{
    bool result = E.head().type() == modifiable_type;
    assert(result == E.head().is_a<modifiable>());
    return result;
}

bool is_identifier(const expression_ref& E)
{
    return E.is_a<identifier>();
}

bool is_reg_var(const expression_ref& E)
{
    return E.is_a<reg_var>();
}

bool is_reglike(const expression_ref& E)
{
    return is_dummy(E) or is_parameter(E) or is_modifiable(E) or is_reg_var(E) or E.is_index_var() or is_identifier(E);
}

bool is_wildcard(const dummy& d)
{
    return d.is_wildcard();
}

// Remove in favor of is_dummy?
bool is_wildcard(const expression_ref& E)
{
    if (is_dummy(E))
    {
	assert(not E.size());
	dummy d = E.as_<dummy>();
	return is_wildcard(d);
    }
    else
	return false;
}

expression_ref launchbury_unnormalize(const expression_ref& E)
{
    // 1. Var
    // 5. (partial) Literal constant.  Treat as 0-arg constructor.
    if (not E.size() or is_modifiable(E))
	return E;

    // 2. Lambda
    if (E.head().is_a<lambda>())
    {
	assert(E.size() == 2);
	expression* V = E.as_expression().clone();
	V->sub[1] = launchbury_unnormalize(E.sub()[1]);

	if (V->sub[1].ptr() == E.sub()[1].ptr())
	    return E;
	else
	    return V;
    }

    // 6. Case
    if (E.head().is_a<Case>())
    {
	expression* V = E.as_expression().clone();

	// Unormalize the object
	V->sub[0] = launchbury_unnormalize(V->sub[0]);

	const int L = V->sub.size()/2 - 1;
	// Just unnormalize the bodies
	for(int i=0;i<L;i++)
	    V->sub[2+2*i] = launchbury_unnormalize(V->sub[2+2*i]);
    
	return V;
    }

    // 4. Constructor
    if (E.head().is_a<constructor>() or E.head().is_a<Operation>())
    {
	expression* V = E.as_expression().clone();
	for(int i=0;i<E.size();i++)
	    V->sub[i] = launchbury_unnormalize(E.sub()[i]);
	return V;
    }

    // 5. Let 
    if (E.head().is_a<let_obj>())
    {
	vector<expression_ref> vars;
	vector<expression_ref> bodies;
	expression_ref T;
	parse_let_expression(E, vars, bodies, T);

	// unnormalize T and the bodies
	T = launchbury_unnormalize(T);
	for(int i=0; i<vars.size(); i++)
	    bodies[i] = launchbury_unnormalize(bodies[i]);

	/*
	  Identify cycles of size > 1...
	  But what is the optimal behavior in that case?
	  matrix<int> U(vars.size(), vars.size());
	  for(int i=0;i<vars.size();i++)
	  {
	  std::set<dummy> free = get_free_indices(bodies[i]);
	  for(int j=0;j<vars.size();j++)
	  if (free.find(vars[j]))
	  U(i,j) = 0;
	  }
	*/

	// substitute for non-recursive lets
	bool changed = true;
	while(changed)
	{
	    changed = false;

	    for(int i=vars.size()-1; i>=0; i--)
	    {
		auto& V = vars[i].as_<dummy>();
		std::set<dummy> free = get_free_indices(bodies[i]);

		// if V references itself then don't substitute it.
		if (free.count(V)) continue;
	
		changed = true;
	
		expression_ref var = vars[i];
		expression_ref body = bodies[i];
	
		vars.erase(vars.begin() + i);
		bodies.erase(bodies.begin() + i);
	
		// substitute for the value of this variable in T and in the remaining bodies;
		for(int j=0;j<vars.size();j++)
		    bodies[j] = substitute(bodies[j], var, body);
		T = substitute(T, var, body);
	    }
	}

	return let_expression(vars, bodies, T);
    }

    std::cerr<<"I don't recognize expression '"+ E.print() + "'\n";
    return E;
}

expression_ref unlet(const expression_ref& E)
{
    // 1. Var
    // 5. (partial) Literal constant.  Treat as 0-arg constructor.
    if (not E.size() or is_modifiable(E))
	return E;
  
    // 2. Lambda
    if (E.head().is_a<lambda>())
    {
	assert(E.size() == 2);
	expression* V = E.as_expression().clone();
	V->sub[1] = unlet(E.sub()[1]);

	if (V->sub[1].ptr() == E.sub()[1].ptr())
	    return E;
	else
	    return V;
    }

    // 6. Case
    if (E.head().is_a<Case>())
    {
	expression* V = E.as_expression().clone();

	// Unormalize the object
	V->sub[0] = unlet(V->sub[0]);

	const int L = (V->sub.size() - 1)/2;
	// Just unnormalize the bodies
	for(int i=0;i<L;i++)
	    V->sub[2+2*i] = unlet(V->sub[2+2*i]);
    
	return V;
    }

    // 4. Constructor
    if (E.head().is_a<constructor>() or E.head().is_a<Operation>())
    {
	expression* V = E.as_expression().clone();
	for(int i=0;i<E.size();i++)
	    V->sub[i] = unlet(E.sub()[i]);
	return V;
    }

    // 5. Let 
    if (E.head().is_a<let_obj>())
    {
	vector<expression_ref> vars;
	vector<expression_ref> bodies;
	expression_ref T;
	parse_let_expression(E, vars, bodies, T);

	// unnormalize T and the bodies
	T = unlet(T);
	for(int i=0; i<vars.size(); i++)
	    bodies[i] = unlet(bodies[i]);

	// substitute for non-recursive lets
	bool changed = true;
	while(changed)
	{
	    changed = false;

	    for(int i=vars.size()-1; i>=0; i--)
	    {
		assert(vars[i].is_a<dummy>());

		if (n_free_occurrences(bodies[i],vars[i])) continue;

		int count = n_free_occurrences(T, vars[i]);
		for(const auto& b: bodies)
		    count += n_free_occurrences(b, vars[i]);

		if (count != 1) continue;

		changed = true;
	
		expression_ref var = vars[i];
		expression_ref body = bodies[i];
	
		vars.erase(vars.begin() + i);
		bodies.erase(bodies.begin() + i);
	
		// substitute for the value of this variable in T and in the remaining bodies;
		for(int j=0;j<vars.size();j++)
		    bodies[j] = substitute(bodies[j], var, body);
		T = substitute(T, var, body);
	    }
	}

	return let_expression(vars, bodies, T);
    }

    std::cerr<<"I don't recognize expression '"+ E.print() + "'\n";
    return E;
}

const expression_ref v0 = dummy(0);
const expression_ref v1 = dummy(1);
const expression_ref v2 = dummy(2);
const expression_ref v3 = dummy(3);
const expression_ref v4 = dummy(4);
const expression_ref v5 = dummy(5);
const expression_ref v6 = dummy(6);
const expression_ref v7 = dummy(7);
const expression_ref v8 = dummy(8);

expression_ref char_list(const string& s)
{
    vector<expression_ref> letters;
    for(char c: s)
	letters.push_back(c);
    return get_list(letters);
}

expression_ref parse_object(const string& s)
{
    bool bool_value;
    int int_value;
    double double_value;

    if (can_be_converted_to<int>(s, int_value))
	return int_value;
    else if (can_be_converted_to<double>(s, double_value))
	return double_value;
    else if (can_be_converted_to<bool>(s, bool_value))
    {
	if (bool_value)
	    return constructor("Prelude.True",0);
	else
	    return constructor("Prelude.False",0);
    }
    else if (s.size() >= 2 and s[0] == '"' and s[s.size()-1] == '"')
	return String(s.substr(1,s.size()-2));
    else
	throw myexception()<<"Can't convert '"<<s<<"' to bool, int, double, or string!";
}

vector<double> vec_to_double(const std::vector<expression_ref>& v)
{
    vector<double> vv(v.size());
    for(int i=0;i<v.size();i++)
	vv[i] = v[i].as_double();
    return vv;
}

vector<int> vec_to_int(const std::vector<expression_ref>& v)
{
    vector<int> vv(v.size());
    for(int i=0;i<v.size();i++)
	vv[i] = v[i].as_int();
    return vv;
}
