{
    "name": "nonRev",
    "synonyms": ["nonrev"],
    "title":"The General Non-Reversible rate matrix",
    "result_type": "CTMC<a>",
    "call": "nonRev'(@a,@rates)",
    "import": ["SModel.NonReversibleMarkov"],
    "args": [
        {
            "name": "rates",
            "type": "List<(String,Double)>",
	    "default_value":"~symmetric_dirichlet_on(ordered_letter_pairs(@a),1)",
	    "description":"rate matrix"
        },
        {
            "name": "a",
            "type": "a",
            "default_value": "get_state(alphabet)",
	    "description": "The alphabet"
        }
    ],
    "computed": [
	{
	    "name": "eqFrequencies",
	    "value": "labelledEqFrequencies(nonRev'(@a,@rates))"
	},
	{
	    "name": "flux",
	    "value": "labelledUpperTriangle(@a, eqFlux(nonRev'(@a,@rates)))"
	},
	{
	    "name": "nonreversibility",
	    "value": "eqRelFlux(nonRev'(@a,@rates))"
	},
	{
	    "name": "flow",
	    "value": "labelledOffDiagonal(@a, eqFlow(nonRev'(@a,@rates)))"
	}
    ],
    "description": "The general non-reversible rate matrix Q(i,j).  Requires a rooted tree.\n\nNon-reversible rate matrices create letter trajectories that have different probabilities in the forwards and backwards direction.  This means that likelihoods under non-reversible models depend on the root location and can be used to estimate the root location.\n\nAt equilibrium, non-reversible models contain directional circular flow around paths of 3 or more letters. The direction of flow around these paths is what indicates that time is going forward or backward.\n\nAlso note that even reversible models are directional if they start out of equilibrium.  Non-reversible models are directional even at equilibrium.  This model assumes that the initial frequencies are the equilibrium frequencies.\n\nThe flux measures the degree of non-reversibility:\n  flux(i,j) = pi(i)Q(i,j) - pi(j)Q(j,i)\nIf flux(i,j) is positive then there is excess flow from i -> j at equilibrium.  If it is negative then the flow is from j -> i.\n\nThe nonreversibility ranges between 0 and 1, and is given by the total flux over the total flow:\n\n   0.5*sum(abs(flux))/sum(abs(flow))\n\nThe 0.5 avoids overcounting the flux.",
    "see": ["gtr","nonEq"],
    "extract": "all"
}
