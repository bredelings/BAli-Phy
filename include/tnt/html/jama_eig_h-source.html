<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>jama_eig.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.5 on Wed Aug 28 02:59:45 2002 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; </center>
<hr><h1>jama_eig.h</h1><a href="jama_eig_h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="preprocessor">#ifndef JAMA_EIG_H</font>
00002 <font class="preprocessor"></font><font class="preprocessor">#define JAMA_EIG_H</font>
00003 <font class="preprocessor"></font>
00004 
00005 <font class="preprocessor">#include "tnt_array1d.h"</font>
00006 <font class="preprocessor">#include "tnt_array2d.h"</font>
00007 <font class="preprocessor">#include "tnt_math_utils.h"</font>
00008 
00009 
00010 <font class="keyword">using</font> <font class="keyword">namespace </font>TNT;
00011 
00012 
00013 <font class="keyword">namespace </font>JAMA
00014 {
00015 
00065 
00066 template &lt;class Real&gt;
<a name="l00067"></a><a class="code" href="class_JAMA__Eigenvalue.html">00067</a> <font class="keyword">class </font>Eigenvalue
00068 {
00069 
00070 
00072     <font class="keywordtype">int</font> n;
00073 
00074    <font class="keywordtype">int</font> issymmetric; <font class="comment">/* boolean*/</font>
00075 
00077 
00078    TNT::Array1D&lt;Real&gt; d;         <font class="comment">/* real part */</font>
00079    TNT::Array1D&lt;Real&gt; e;         <font class="comment">/* img part */</font>
00080 
00082     TNT::Array2D&lt;Real&gt; V;
00083 
00087    TNT::Array2D&lt;Real&gt; H;
00088    
00089 
00093    TNT::Array1D&lt;Real&gt; ort;
00094 
00095 
00096    <font class="comment">// Symmetric Householder reduction to tridiagonal form.</font>
00097 
00098    <font class="keywordtype">void</font> tred2()<font class="keyword"> </font>{
00099 
00100    <font class="comment">//  This is derived from the Algol procedures tred2 by</font>
00101    <font class="comment">//  Bowdler, Martin, Reinsch, and Wilkinson, Handbook for</font>
00102    <font class="comment">//  Auto. Comp., Vol.ii-Linear Algebra, and the corresponding</font>
00103    <font class="comment">//  Fortran subroutine in EISPACK.</font>
00104 
00105       <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = 0; j &lt; n; j++) {
00106          d[j] = V[n-1][j];
00107       }
00108 
00109       <font class="comment">// Householder reduction to tridiagonal form.</font>
00110    
00111       <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = n-1; i &gt; 0; i--) {
00112    
00113          <font class="comment">// Scale to avoid under/overflow.</font>
00114    
00115          Real scale = 0.0;
00116          Real h = 0.0;
00117          <font class="keywordflow">for</font> (<font class="keywordtype">int</font> k = 0; k &lt; i; k++) {
00118             scale = scale + abs(d[k]);
00119          }
00120          <font class="keywordflow">if</font> (scale == 0.0) {
00121             e[i] = d[i-1];
00122             <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = 0; j &lt; i; j++) {
00123                d[j] = V[i-1][j];
00124                V[i][j] = 0.0;
00125                V[j][i] = 0.0;
00126             }
00127          } <font class="keywordflow">else</font> {
00128    
00129             <font class="comment">// Generate Householder vector.</font>
00130    
00131             <font class="keywordflow">for</font> (<font class="keywordtype">int</font> k = 0; k &lt; i; k++) {
00132                d[k] /= scale;
00133                h += d[k] * d[k];
00134             }
00135             Real f = d[i-1];
00136             Real g = sqrt(h);
00137             <font class="keywordflow">if</font> (f &gt; 0) {
00138                g = -g;
00139             }
00140             e[i] = scale * g;
00141             h = h - f * g;
00142             d[i-1] = f - g;
00143             <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = 0; j &lt; i; j++) {
00144                e[j] = 0.0;
00145             }
00146    
00147             <font class="comment">// Apply similarity transformation to remaining columns.</font>
00148    
00149             <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = 0; j &lt; i; j++) {
00150                f = d[j];
00151                V[j][i] = f;
00152                g = e[j] + V[j][j] * f;
00153                <font class="keywordflow">for</font> (<font class="keywordtype">int</font> k = j+1; k &lt;= i-1; k++) {
00154                   g += V[k][j] * d[k];
00155                   e[k] += V[k][j] * f;
00156                }
00157                e[j] = g;
00158             }
00159             f = 0.0;
00160             <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = 0; j &lt; i; j++) {
00161                e[j] /= h;
00162                f += e[j] * d[j];
00163             }
00164             Real hh = f / (h + h);
00165             <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = 0; j &lt; i; j++) {
00166                e[j] -= hh * d[j];
00167             }
00168             <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = 0; j &lt; i; j++) {
00169                f = d[j];
00170                g = e[j];
00171                <font class="keywordflow">for</font> (<font class="keywordtype">int</font> k = j; k &lt;= i-1; k++) {
00172                   V[k][j] -= (f * e[k] + g * d[k]);
00173                }
00174                d[j] = V[i-1][j];
00175                V[i][j] = 0.0;
00176             }
00177          }
00178          d[i] = h;
00179       }
00180    
00181       <font class="comment">// Accumulate transformations.</font>
00182    
00183       <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = 0; i &lt; n-1; i++) {
00184          V[n-1][i] = V[i][i];
00185          V[i][i] = 1.0;
00186          Real h = d[i+1];
00187          <font class="keywordflow">if</font> (h != 0.0) {
00188             <font class="keywordflow">for</font> (<font class="keywordtype">int</font> k = 0; k &lt;= i; k++) {
00189                d[k] = V[k][i+1] / h;
00190             }
00191             <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = 0; j &lt;= i; j++) {
00192                Real g = 0.0;
00193                <font class="keywordflow">for</font> (<font class="keywordtype">int</font> k = 0; k &lt;= i; k++) {
00194                   g += V[k][i+1] * V[k][j];
00195                }
00196                <font class="keywordflow">for</font> (<font class="keywordtype">int</font> k = 0; k &lt;= i; k++) {
00197                   V[k][j] -= g * d[k];
00198                }
00199             }
00200          }
00201          <font class="keywordflow">for</font> (<font class="keywordtype">int</font> k = 0; k &lt;= i; k++) {
00202             V[k][i+1] = 0.0;
00203          }
00204       }
00205       <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = 0; j &lt; n; j++) {
00206          d[j] = V[n-1][j];
00207          V[n-1][j] = 0.0;
00208       }
00209       V[n-1][n-1] = 1.0;
00210       e[0] = 0.0;
00211    } 
00212 
00213    <font class="comment">// Symmetric tridiagonal QL algorithm.</font>
00214    
00215    <font class="keywordtype">void</font> tql2 ()<font class="keyword"> </font>{
00216 
00217    <font class="comment">//  This is derived from the Algol procedures tql2, by</font>
00218    <font class="comment">//  Bowdler, Martin, Reinsch, and Wilkinson, Handbook for</font>
00219    <font class="comment">//  Auto. Comp., Vol.ii-Linear Algebra, and the corresponding</font>
00220    <font class="comment">//  Fortran subroutine in EISPACK.</font>
00221    
00222       <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = 1; i &lt; n; i++) {
00223          e[i-1] = e[i];
00224       }
00225       e[n-1] = 0.0;
00226    
00227       Real f = 0.0;
00228       Real tst1 = 0.0;
00229       Real eps = pow(2.0,-52.0);
00230       <font class="keywordflow">for</font> (<font class="keywordtype">int</font> l = 0; l &lt; n; l++) {
00231 
00232          <font class="comment">// Find small subdiagonal element</font>
00233    
00234          tst1 = max(tst1,abs(d[l]) + abs(e[l]));
00235          <font class="keywordtype">int</font> m = l;
00236 
00237         <font class="comment">// Original while-loop from Java code</font>
00238          <font class="keywordflow">while</font> (m &lt; n) {
00239             <font class="keywordflow">if</font> (abs(e[m]) &lt;= eps*tst1) {
00240                <font class="keywordflow">break</font>;
00241             }
00242             m++;
00243          }
00244 
00245    
00246          <font class="comment">// If m == l, d[l] is an eigenvalue,</font>
00247          <font class="comment">// otherwise, iterate.</font>
00248    
00249          <font class="keywordflow">if</font> (m &gt; l) {
00250             <font class="keywordtype">int</font> iter = 0;
00251             <font class="keywordflow">do</font> {
00252                iter = iter + 1;  <font class="comment">// (Could check iteration count here.)</font>
00253    
00254                <font class="comment">// Compute implicit shift</font>
00255    
00256                Real g = d[l];
00257                Real p = (d[l+1] - g) / (2.0 * e[l]);
00258                Real r = hypot(p,1.0);
00259                <font class="keywordflow">if</font> (p &lt; 0) {
00260                   r = -r;
00261                }
00262                d[l] = e[l] / (p + r);
00263                d[l+1] = e[l] * (p + r);
00264                Real dl1 = d[l+1];
00265                Real h = g - d[l];
00266                <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = l+2; i &lt; n; i++) {
00267                   d[i] -= h;
00268                }
00269                f = f + h;
00270    
00271                <font class="comment">// Implicit QL transformation.</font>
00272    
00273                p = d[m];
00274                Real c = 1.0;
00275                Real c2 = c;
00276                Real c3 = c;
00277                Real el1 = e[l+1];
00278                Real s = 0.0;
00279                Real s2 = 0.0;
00280                <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = m-1; i &gt;= l; i--) {
00281                   c3 = c2;
00282                   c2 = c;
00283                   s2 = s;
00284                   g = c * e[i];
00285                   h = c * p;
00286                   r = hypot(p,e[i]);
00287                   e[i+1] = s * r;
00288                   s = e[i] / r;
00289                   c = p / r;
00290                   p = c * d[i] - s * g;
00291                   d[i+1] = h + s * (c * g + s * d[i]);
00292    
00293                   <font class="comment">// Accumulate transformation.</font>
00294    
00295                   <font class="keywordflow">for</font> (<font class="keywordtype">int</font> k = 0; k &lt; n; k++) {
00296                      h = V[k][i+1];
00297                      V[k][i+1] = s * V[k][i] + c * h;
00298                      V[k][i] = c * V[k][i] - s * h;
00299                   }
00300                }
00301                p = -s * s2 * c3 * el1 * e[l] / dl1;
00302                e[l] = s * p;
00303                d[l] = c * p;
00304    
00305                <font class="comment">// Check for convergence.</font>
00306    
00307             } <font class="keywordflow">while</font> (abs(e[l]) &gt; eps*tst1);
00308          }
00309          d[l] = d[l] + f;
00310          e[l] = 0.0;
00311       }
00312      
00313       <font class="comment">// Sort eigenvalues and corresponding vectors.</font>
00314    
00315       <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = 0; i &lt; n-1; i++) {
00316          <font class="keywordtype">int</font> k = i;
00317          Real p = d[i];
00318          <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = i+1; j &lt; n; j++) {
00319             <font class="keywordflow">if</font> (d[j] &lt; p) {
00320                k = j;
00321                p = d[j];
00322             }
00323          }
00324          <font class="keywordflow">if</font> (k != i) {
00325             d[k] = d[i];
00326             d[i] = p;
00327             <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = 0; j &lt; n; j++) {
00328                p = V[j][i];
00329                V[j][i] = V[j][k];
00330                V[j][k] = p;
00331             }
00332          }
00333       }
00334    }
00335 
00336    <font class="comment">// Nonsymmetric reduction to Hessenberg form.</font>
00337 
00338    <font class="keywordtype">void</font> orthes ()<font class="keyword"> </font>{
00339    
00340       <font class="comment">//  This is derived from the Algol procedures orthes and ortran,</font>
00341       <font class="comment">//  by Martin and Wilkinson, Handbook for Auto. Comp.,</font>
00342       <font class="comment">//  Vol.ii-Linear Algebra, and the corresponding</font>
00343       <font class="comment">//  Fortran subroutines in EISPACK.</font>
00344    
00345       <font class="keywordtype">int</font> low = 0;
00346       <font class="keywordtype">int</font> high = n-1;
00347    
00348       <font class="keywordflow">for</font> (<font class="keywordtype">int</font> m = low+1; m &lt;= high-1; m++) {
00349    
00350          <font class="comment">// Scale column.</font>
00351    
00352          Real scale = 0.0;
00353          <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = m; i &lt;= high; i++) {
00354             scale = scale + abs(H[i][m-1]);
00355          }
00356          <font class="keywordflow">if</font> (scale != 0.0) {
00357    
00358             <font class="comment">// Compute Householder transformation.</font>
00359    
00360             Real h = 0.0;
00361             <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = high; i &gt;= m; i--) {
00362                ort[i] = H[i][m-1]/scale;
00363                h += ort[i] * ort[i];
00364             }
00365             Real g = sqrt(h);
00366             <font class="keywordflow">if</font> (ort[m] &gt; 0) {
00367                g = -g;
00368             }
00369             h = h - ort[m] * g;
00370             ort[m] = ort[m] - g;
00371    
00372             <font class="comment">// Apply Householder similarity transformation</font>
00373             <font class="comment">// H = (I-u*u'/h)*H*(I-u*u')/h)</font>
00374    
00375             <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = m; j &lt; n; j++) {
00376                Real f = 0.0;
00377                <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = high; i &gt;= m; i--) {
00378                   f += ort[i]*H[i][j];
00379                }
00380                f = f/h;
00381                <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = m; i &lt;= high; i++) {
00382                   H[i][j] -= f*ort[i];
00383                }
00384            }
00385    
00386            <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = 0; i &lt;= high; i++) {
00387                Real f = 0.0;
00388                <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = high; j &gt;= m; j--) {
00389                   f += ort[j]*H[i][j];
00390                }
00391                f = f/h;
00392                <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = m; j &lt;= high; j++) {
00393                   H[i][j] -= f*ort[j];
00394                }
00395             }
00396             ort[m] = scale*ort[m];
00397             H[m][m-1] = scale*g;
00398          }
00399       }
00400    
00401       <font class="comment">// Accumulate transformations (Algol's ortran).</font>
00402 
00403       <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = 0; i &lt; n; i++) {
00404          <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = 0; j &lt; n; j++) {
00405             V[i][j] = (i == j ? 1.0 : 0.0);
00406          }
00407       }
00408 
00409       <font class="keywordflow">for</font> (<font class="keywordtype">int</font> m = high-1; m &gt;= low+1; m--) {
00410          <font class="keywordflow">if</font> (H[m][m-1] != 0.0) {
00411             <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = m+1; i &lt;= high; i++) {
00412                ort[i] = H[i][m-1];
00413             }
00414             <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = m; j &lt;= high; j++) {
00415                Real g = 0.0;
00416                <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = m; i &lt;= high; i++) {
00417                   g += ort[i] * V[i][j];
00418                }
00419                <font class="comment">// Double division avoids possible underflow</font>
00420                g = (g / ort[m]) / H[m][m-1];
00421                <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = m; i &lt;= high; i++) {
00422                   V[i][j] += g * ort[i];
00423                }
00424             }
00425          }
00426       }
00427    }
00428 
00429 
00430    <font class="comment">// Complex scalar division.</font>
00431 
00432    Real cdivr, cdivi;
00433    <font class="keywordtype">void</font> cdiv(Real xr, Real xi, Real yr, Real yi)<font class="keyword"> </font>{
00434       Real r,d;
00435       <font class="keywordflow">if</font> (abs(yr) &gt; abs(yi)) {
00436          r = yi/yr;
00437          d = yr + r*yi;
00438          cdivr = (xr + r*xi)/d;
00439          cdivi = (xi - r*xr)/d;
00440       } <font class="keywordflow">else</font> {
00441          r = yr/yi;
00442          d = yi + r*yr;
00443          cdivr = (r*xr + xi)/d;
00444          cdivi = (r*xi - xr)/d;
00445       }
00446    }
00447 
00448 
00449    <font class="comment">// Nonsymmetric reduction from Hessenberg to real Schur form.</font>
00450 
00451    <font class="keywordtype">void</font> hqr2 ()<font class="keyword"> </font>{
00452    
00453       <font class="comment">//  This is derived from the Algol procedure hqr2,</font>
00454       <font class="comment">//  by Martin and Wilkinson, Handbook for Auto. Comp.,</font>
00455       <font class="comment">//  Vol.ii-Linear Algebra, and the corresponding</font>
00456       <font class="comment">//  Fortran subroutine in EISPACK.</font>
00457    
00458       <font class="comment">// Initialize</font>
00459    
00460       <font class="keywordtype">int</font> nn = this-&gt;n;
00461       <font class="keywordtype">int</font> n = nn-1;
00462       <font class="keywordtype">int</font> low = 0;
00463       <font class="keywordtype">int</font> high = nn-1;
00464       Real eps = pow(2.0,-52.0);
00465       Real exshift = 0.0;
00466       Real p=0,q=0,r=0,s=0,z=0,t,w,x,y;
00467    
00468       <font class="comment">// Store roots isolated by balanc and compute matrix norm</font>
00469    
00470       Real norm = 0.0;
00471       <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = 0; i &lt; nn; i++) {
00472          <font class="keywordflow">if</font> ((i &lt; low) || (i &gt; high)) {
00473             d[i] = H[i][i];
00474             e[i] = 0.0;
00475          }
00476          <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = max(i-1,0); j &lt; nn; j++) {
00477             norm = norm + abs(H[i][j]);
00478          }
00479       }
00480    
00481       <font class="comment">// Outer loop over eigenvalue index</font>
00482    
00483       <font class="keywordtype">int</font> iter = 0;
00484       <font class="keywordflow">while</font> (n &gt;= low) {
00485    
00486          <font class="comment">// Look for single small sub-diagonal element</font>
00487    
00488          <font class="keywordtype">int</font> l = n;
00489          <font class="keywordflow">while</font> (l &gt; low) {
00490             s = abs(H[l-1][l-1]) + abs(H[l][l]);
00491             <font class="keywordflow">if</font> (s == 0.0) {
00492                s = norm;
00493             }
00494             <font class="keywordflow">if</font> (abs(H[l][l-1]) &lt; eps * s) {
00495                <font class="keywordflow">break</font>;
00496             }
00497             l--;
00498          }
00499        
00500          <font class="comment">// Check for convergence</font>
00501          <font class="comment">// One root found</font>
00502    
00503          <font class="keywordflow">if</font> (l == n) {
00504             H[n][n] = H[n][n] + exshift;
00505             d[n] = H[n][n];
00506             e[n] = 0.0;
00507             n--;
00508             iter = 0;
00509    
00510          <font class="comment">// Two roots found</font>
00511    
00512          } <font class="keywordflow">else</font> <font class="keywordflow">if</font> (l == n-1) {
00513             w = H[n][n-1] * H[n-1][n];
00514             p = (H[n-1][n-1] - H[n][n]) / 2.0;
00515             q = p * p + w;
00516             z = sqrt(abs(q));
00517             H[n][n] = H[n][n] + exshift;
00518             H[n-1][n-1] = H[n-1][n-1] + exshift;
00519             x = H[n][n];
00520    
00521             <font class="comment">// Real pair</font>
00522    
00523             <font class="keywordflow">if</font> (q &gt;= 0) {
00524                <font class="keywordflow">if</font> (p &gt;= 0) {
00525                   z = p + z;
00526                } <font class="keywordflow">else</font> {
00527                   z = p - z;
00528                }
00529                d[n-1] = x + z;
00530                d[n] = d[n-1];
00531                <font class="keywordflow">if</font> (z != 0.0) {
00532                   d[n] = x - w / z;
00533                }
00534                e[n-1] = 0.0;
00535                e[n] = 0.0;
00536                x = H[n][n-1];
00537                s = abs(x) + abs(z);
00538                p = x / s;
00539                q = z / s;
00540                r = sqrt(p * p+q * q);
00541                p = p / r;
00542                q = q / r;
00543    
00544                <font class="comment">// Row modification</font>
00545    
00546                <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = n-1; j &lt; nn; j++) {
00547                   z = H[n-1][j];
00548                   H[n-1][j] = q * z + p * H[n][j];
00549                   H[n][j] = q * H[n][j] - p * z;
00550                }
00551    
00552                <font class="comment">// Column modification</font>
00553    
00554                <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = 0; i &lt;= n; i++) {
00555                   z = H[i][n-1];
00556                   H[i][n-1] = q * z + p * H[i][n];
00557                   H[i][n] = q * H[i][n] - p * z;
00558                }
00559    
00560                <font class="comment">// Accumulate transformations</font>
00561    
00562                <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = low; i &lt;= high; i++) {
00563                   z = V[i][n-1];
00564                   V[i][n-1] = q * z + p * V[i][n];
00565                   V[i][n] = q * V[i][n] - p * z;
00566                }
00567    
00568             <font class="comment">// Complex pair</font>
00569    
00570             } <font class="keywordflow">else</font> {
00571                d[n-1] = x + p;
00572                d[n] = x + p;
00573                e[n-1] = z;
00574                e[n] = -z;
00575             }
00576             n = n - 2;
00577             iter = 0;
00578    
00579          <font class="comment">// No convergence yet</font>
00580    
00581          } <font class="keywordflow">else</font> {
00582    
00583             <font class="comment">// Form shift</font>
00584    
00585             x = H[n][n];
00586             y = 0.0;
00587             w = 0.0;
00588             <font class="keywordflow">if</font> (l &lt; n) {
00589                y = H[n-1][n-1];
00590                w = H[n][n-1] * H[n-1][n];
00591             }
00592    
00593             <font class="comment">// Wilkinson's original ad hoc shift</font>
00594    
00595             <font class="keywordflow">if</font> (iter == 10) {
00596                exshift += x;
00597                <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = low; i &lt;= n; i++) {
00598                   H[i][i] -= x;
00599                }
00600                s = abs(H[n][n-1]) + abs(H[n-1][n-2]);
00601                x = y = 0.75 * s;
00602                w = -0.4375 * s * s;
00603             }
00604 
00605             <font class="comment">// MATLAB's new ad hoc shift</font>
00606 
00607             <font class="keywordflow">if</font> (iter == 30) {
00608                 s = (y - x) / 2.0;
00609                 s = s * s + w;
00610                 <font class="keywordflow">if</font> (s &gt; 0) {
00611                     s = sqrt(s);
00612                     <font class="keywordflow">if</font> (y &lt; x) {
00613                        s = -s;
00614                     }
00615                     s = x - w / ((y - x) / 2.0 + s);
00616                     <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = low; i &lt;= n; i++) {
00617                        H[i][i] -= s;
00618                     }
00619                     exshift += s;
00620                     x = y = w = 0.964;
00621                 }
00622             }
00623    
00624             iter = iter + 1;   <font class="comment">// (Could check iteration count here.)</font>
00625    
00626             <font class="comment">// Look for two consecutive small sub-diagonal elements</font>
00627    
00628             <font class="keywordtype">int</font> m = n-2;
00629             <font class="keywordflow">while</font> (m &gt;= l) {
00630                z = H[m][m];
00631                r = x - z;
00632                s = y - z;
00633                p = (r * s - w) / H[m+1][m] + H[m][m+1];
00634                q = H[m+1][m+1] - z - r - s;
00635                r = H[m+2][m+1];
00636                s = abs(p) + abs(q) + abs(r);
00637                p = p / s;
00638                q = q / s;
00639                r = r / s;
00640                <font class="keywordflow">if</font> (m == l) {
00641                   <font class="keywordflow">break</font>;
00642                }
00643                <font class="keywordflow">if</font> (abs(H[m][m-1]) * (abs(q) + abs(r)) &lt;
00644                   eps * (abs(p) * (abs(H[m-1][m-1]) + abs(z) +
00645                   abs(H[m+1][m+1])))) {
00646                      <font class="keywordflow">break</font>;
00647                }
00648                m--;
00649             }
00650    
00651             <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = m+2; i &lt;= n; i++) {
00652                H[i][i-2] = 0.0;
00653                <font class="keywordflow">if</font> (i &gt; m+2) {
00654                   H[i][i-3] = 0.0;
00655                }
00656             }
00657    
00658             <font class="comment">// Double QR step involving rows l:n and columns m:n</font>
00659    
00660             <font class="keywordflow">for</font> (<font class="keywordtype">int</font> k = m; k &lt;= n-1; k++) {
00661                <font class="keywordtype">int</font> notlast = (k != n-1);
00662                <font class="keywordflow">if</font> (k != m) {
00663                   p = H[k][k-1];
00664                   q = H[k+1][k-1];
00665                   r = (notlast ? H[k+2][k-1] : 0.0);
00666                   x = abs(p) + abs(q) + abs(r);
00667                   <font class="keywordflow">if</font> (x != 0.0) {
00668                      p = p / x;
00669                      q = q / x;
00670                      r = r / x;
00671                   }
00672                }
00673                <font class="keywordflow">if</font> (x == 0.0) {
00674                   <font class="keywordflow">break</font>;
00675                }
00676                s = sqrt(p * p + q * q + r * r);
00677                <font class="keywordflow">if</font> (p &lt; 0) {
00678                   s = -s;
00679                }
00680                <font class="keywordflow">if</font> (s != 0) {
00681                   <font class="keywordflow">if</font> (k != m) {
00682                      H[k][k-1] = -s * x;
00683                   } <font class="keywordflow">else</font> <font class="keywordflow">if</font> (l != m) {
00684                      H[k][k-1] = -H[k][k-1];
00685                   }
00686                   p = p + s;
00687                   x = p / s;
00688                   y = q / s;
00689                   z = r / s;
00690                   q = q / p;
00691                   r = r / p;
00692    
00693                   <font class="comment">// Row modification</font>
00694    
00695                   <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = k; j &lt; nn; j++) {
00696                      p = H[k][j] + q * H[k+1][j];
00697                      <font class="keywordflow">if</font> (notlast) {
00698                         p = p + r * H[k+2][j];
00699                         H[k+2][j] = H[k+2][j] - p * z;
00700                      }
00701                      H[k][j] = H[k][j] - p * x;
00702                      H[k+1][j] = H[k+1][j] - p * y;
00703                   }
00704    
00705                   <font class="comment">// Column modification</font>
00706    
00707                   <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = 0; i &lt;= min(n,k+3); i++) {
00708                      p = x * H[i][k] + y * H[i][k+1];
00709                      <font class="keywordflow">if</font> (notlast) {
00710                         p = p + z * H[i][k+2];
00711                         H[i][k+2] = H[i][k+2] - p * r;
00712                      }
00713                      H[i][k] = H[i][k] - p;
00714                      H[i][k+1] = H[i][k+1] - p * q;
00715                   }
00716    
00717                   <font class="comment">// Accumulate transformations</font>
00718    
00719                   <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = low; i &lt;= high; i++) {
00720                      p = x * V[i][k] + y * V[i][k+1];
00721                      <font class="keywordflow">if</font> (notlast) {
00722                         p = p + z * V[i][k+2];
00723                         V[i][k+2] = V[i][k+2] - p * r;
00724                      }
00725                      V[i][k] = V[i][k] - p;
00726                      V[i][k+1] = V[i][k+1] - p * q;
00727                   }
00728                }  <font class="comment">// (s != 0)</font>
00729             }  <font class="comment">// k loop</font>
00730          }  <font class="comment">// check convergence</font>
00731       }  <font class="comment">// while (n &gt;= low)</font>
00732       
00733       <font class="comment">// Backsubstitute to find vectors of upper triangular form</font>
00734 
00735       <font class="keywordflow">if</font> (norm == 0.0) {
00736          <font class="keywordflow">return</font>;
00737       }
00738    
00739       <font class="keywordflow">for</font> (n = nn-1; n &gt;= 0; n--) {
00740          p = d[n];
00741          q = e[n];
00742    
00743          <font class="comment">// Real vector</font>
00744    
00745          <font class="keywordflow">if</font> (q == 0) {
00746             <font class="keywordtype">int</font> l = n;
00747             H[n][n] = 1.0;
00748             <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = n-1; i &gt;= 0; i--) {
00749                w = H[i][i] - p;
00750                r = 0.0;
00751                <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = l; j &lt;= n; j++) {
00752                   r = r + H[i][j] * H[j][n];
00753                }
00754                <font class="keywordflow">if</font> (e[i] &lt; 0.0) {
00755                   z = w;
00756                   s = r;
00757                } <font class="keywordflow">else</font> {
00758                   l = i;
00759                   <font class="keywordflow">if</font> (e[i] == 0.0) {
00760                      <font class="keywordflow">if</font> (w != 0.0) {
00761                         H[i][n] = -r / w;
00762                      } <font class="keywordflow">else</font> {
00763                         H[i][n] = -r / (eps * norm);
00764                      }
00765    
00766                   <font class="comment">// Solve real equations</font>
00767    
00768                   } <font class="keywordflow">else</font> {
00769                      x = H[i][i+1];
00770                      y = H[i+1][i];
00771                      q = (d[i] - p) * (d[i] - p) + e[i] * e[i];
00772                      t = (x * s - z * r) / q;
00773                      H[i][n] = t;
00774                      <font class="keywordflow">if</font> (abs(x) &gt; abs(z)) {
00775                         H[i+1][n] = (-r - w * t) / x;
00776                      } <font class="keywordflow">else</font> {
00777                         H[i+1][n] = (-s - y * t) / z;
00778                      }
00779                   }
00780    
00781                   <font class="comment">// Overflow control</font>
00782    
00783                   t = abs(H[i][n]);
00784                   <font class="keywordflow">if</font> ((eps * t) * t &gt; 1) {
00785                      <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = i; j &lt;= n; j++) {
00786                         H[j][n] = H[j][n] / t;
00787                      }
00788                   }
00789                }
00790             }
00791    
00792          <font class="comment">// Complex vector</font>
00793    
00794          } <font class="keywordflow">else</font> <font class="keywordflow">if</font> (q &lt; 0) {
00795             <font class="keywordtype">int</font> l = n-1;
00796 
00797             <font class="comment">// Last vector component imaginary so matrix is triangular</font>
00798    
00799             <font class="keywordflow">if</font> (abs(H[n][n-1]) &gt; abs(H[n-1][n])) {
00800                H[n-1][n-1] = q / H[n][n-1];
00801                H[n-1][n] = -(H[n][n] - p) / H[n][n-1];
00802             } <font class="keywordflow">else</font> {
00803                cdiv(0.0,-H[n-1][n],H[n-1][n-1]-p,q);
00804                H[n-1][n-1] = cdivr;
00805                H[n-1][n] = cdivi;
00806             }
00807             H[n][n-1] = 0.0;
00808             H[n][n] = 1.0;
00809             <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = n-2; i &gt;= 0; i--) {
00810                Real ra,sa,vr,vi;
00811                ra = 0.0;
00812                sa = 0.0;
00813                <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = l; j &lt;= n; j++) {
00814                   ra = ra + H[i][j] * H[j][n-1];
00815                   sa = sa + H[i][j] * H[j][n];
00816                }
00817                w = H[i][i] - p;
00818    
00819                <font class="keywordflow">if</font> (e[i] &lt; 0.0) {
00820                   z = w;
00821                   r = ra;
00822                   s = sa;
00823                } <font class="keywordflow">else</font> {
00824                   l = i;
00825                   <font class="keywordflow">if</font> (e[i] == 0) {
00826                      cdiv(-ra,-sa,w,q);
00827                      H[i][n-1] = cdivr;
00828                      H[i][n] = cdivi;
00829                   } <font class="keywordflow">else</font> {
00830    
00831                      <font class="comment">// Solve complex equations</font>
00832    
00833                      x = H[i][i+1];
00834                      y = H[i+1][i];
00835                      vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;
00836                      vi = (d[i] - p) * 2.0 * q;
00837                      <font class="keywordflow">if</font> ((vr == 0.0) &amp;&amp; (vi == 0.0)) {
00838                         vr = eps * norm * (abs(w) + abs(q) +
00839                         abs(x) + abs(y) + abs(z));
00840                      }
00841                      cdiv(x*r-z*ra+q*sa,x*s-z*sa-q*ra,vr,vi);
00842                      H[i][n-1] = cdivr;
00843                      H[i][n] = cdivi;
00844                      <font class="keywordflow">if</font> (abs(x) &gt; (abs(z) + abs(q))) {
00845                         H[i+1][n-1] = (-ra - w * H[i][n-1] + q * H[i][n]) / x;
00846                         H[i+1][n] = (-sa - w * H[i][n] - q * H[i][n-1]) / x;
00847                      } <font class="keywordflow">else</font> {
00848                         cdiv(-r-y*H[i][n-1],-s-y*H[i][n],z,q);
00849                         H[i+1][n-1] = cdivr;
00850                         H[i+1][n] = cdivi;
00851                      }
00852                   }
00853    
00854                   <font class="comment">// Overflow control</font>
00855 
00856                   t = max(abs(H[i][n-1]),abs(H[i][n]));
00857                   <font class="keywordflow">if</font> ((eps * t) * t &gt; 1) {
00858                      <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = i; j &lt;= n; j++) {
00859                         H[j][n-1] = H[j][n-1] / t;
00860                         H[j][n] = H[j][n] / t;
00861                      }
00862                   }
00863                }
00864             }
00865          }
00866       }
00867    
00868       <font class="comment">// Vectors of isolated roots</font>
00869    
00870       <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = 0; i &lt; nn; i++) {
00871          <font class="keywordflow">if</font> (i &lt; low || i &gt; high) {
00872             <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = i; j &lt; nn; j++) {
00873                V[i][j] = H[i][j];
00874             }
00875          }
00876       }
00877    
00878       <font class="comment">// Back transformation to get eigenvectors of original matrix</font>
00879    
00880       <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = nn-1; j &gt;= low; j--) {
00881          <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = low; i &lt;= high; i++) {
00882             z = 0.0;
00883             <font class="keywordflow">for</font> (<font class="keywordtype">int</font> k = low; k &lt;= min(j,high); k++) {
00884                z = z + V[i][k] * H[k][j];
00885             }
00886             V[i][j] = z;
00887          }
00888       }
00889    }
00890 
00891 <font class="keyword">public</font>:
00892 
00893 
00897 
<a name="l00898"></a><a class="code" href="class_JAMA__Eigenvalue.html#a0">00898</a>    <a class="code" href="class_JAMA__Eigenvalue.html#a0">Eigenvalue</a>(<font class="keyword">const</font> TNT::Array2D&lt;Real&gt; &amp;A)<font class="keyword"> </font>{
00899       n = A.dim2();
00900       V = Array2D&lt;Real&gt;(n,n);
00901       d = Array1D&lt;Real&gt;(n);
00902       e = Array1D&lt;Real&gt;(n);
00903 
00904       issymmetric = 1;
00905       <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = 0; (j &lt; n) &amp;&amp; issymmetric; j++) {
00906          <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = 0; (i &lt; n) &amp;&amp; issymmetric; i++) {
00907             issymmetric = (A[i][j] == A[j][i]);
00908          }
00909       }
00910 
00911       <font class="keywordflow">if</font> (issymmetric) {
00912          <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = 0; i &lt; n; i++) {
00913             <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = 0; j &lt; n; j++) {
00914                V[i][j] = A[i][j];
00915             }
00916          }
00917    
00918          <font class="comment">// Tridiagonalize.</font>
00919          tred2();
00920    
00921          <font class="comment">// Diagonalize.</font>
00922          tql2();
00923 
00924       } <font class="keywordflow">else</font> {
00925          H = TNT::Array2D&lt;Real&gt;(n,n);
00926          ort = TNT::Array1D&lt;Real&gt;(n);
00927          
00928          <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = 0; j &lt; n; j++) {
00929             <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = 0; i &lt; n; i++) {
00930                H[i][j] = A[i][j];
00931             }
00932          }
00933    
00934          <font class="comment">// Reduce to Hessenberg form.</font>
00935          orthes();
00936    
00937          <font class="comment">// Reduce Hessenberg to real Schur form.</font>
00938          hqr2();
00939       }
00940    }
00941 
00942 
00946 
<a name="l00947"></a><a class="code" href="class_JAMA__Eigenvalue.html#a1">00947</a>    <font class="keywordtype">void</font> <a class="code" href="class_JAMA__Eigenvalue.html#a1">getV</a> (TNT::Array2D&lt;Real&gt; &amp;V_)<font class="keyword"> </font>{
00948       V_ = V;
00949       <font class="keywordflow">return</font>;
00950    }
00951 
00955 
<a name="l00956"></a><a class="code" href="class_JAMA__Eigenvalue.html#a2">00956</a>    <font class="keywordtype">void</font> <a class="code" href="class_JAMA__Eigenvalue.html#a2">getRealEigenvalues</a> (TNT::Array1D&lt;Real&gt; &amp;d_)<font class="keyword"> </font>{
00957       d_ = d;
00958       <font class="keywordflow">return</font> ;
00959    }
00960 
<a name="l00966"></a><a class="code" href="class_JAMA__Eigenvalue.html#a3">00966</a>    <font class="keywordtype">void</font> <a class="code" href="class_JAMA__Eigenvalue.html#a3">getImagEigenvalues</a> (TNT::Array1D&lt;Real&gt; &amp;e_)<font class="keyword"> </font>{
00967       e_ = e;
00968       <font class="keywordflow">return</font>;
00969    }
00970 
00971    
<a name="l01005"></a><a class="code" href="class_JAMA__Eigenvalue.html#a4">01005</a>    <font class="keywordtype">void</font> <a class="code" href="class_JAMA__Eigenvalue.html#a4">getD</a> (TNT::Array2D&lt;Real&gt; &amp;D)<font class="keyword"> </font>{
01006       D = Array2D&lt;Real&gt;(n,n);
01007       <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = 0; i &lt; n; i++) {
01008          <font class="keywordflow">for</font> (<font class="keywordtype">int</font> j = 0; j &lt; n; j++) {
01009             D[i][j] = 0.0;
01010          }
01011          D[i][i] = d[i];
01012          <font class="keywordflow">if</font> (e[i] &gt; 0) {
01013             D[i][i+1] = e[i];
01014          } <font class="keywordflow">else</font> <font class="keywordflow">if</font> (e[i] &lt; 0) {
01015             D[i][i-1] = e[i];
01016          }
01017       }
01018    }
01019 };
01020 
01021 } <font class="comment">//namespace JAMA</font>
01022 
01023 
01024 <font class="preprocessor">#endif</font>
01025 <font class="preprocessor"></font><font class="comment">// JAMA_EIG_H</font>
</div></pre><hr><address><small>Generated at Wed Aug 28 02:59:45 2002 for TemplateNumericalToolkit(TNT) by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.5 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
